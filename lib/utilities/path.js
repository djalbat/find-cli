"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get entryPathsFromEntryNamesAndDirectoryPath () {
        return entryPathsFromEntryNamesAndDirectoryPath;
    },
    get isDirectoryPathRootDirectoryPath () {
        return isDirectoryPathRootDirectoryPath;
    },
    get stripRootDirectoryFromPath () {
        return stripRootDirectoryFromPath;
    }
});
const _necessary = require("necessary");
const _constants = require("../constants");
const { concatenatePaths } = _necessary.pathUtilities;
function stripRootDirectoryFromPath(path, context) {
    const { rootDirectoryPaths } = context;
    rootDirectoryPaths.some((rootDirectoryPath)=>{
        const pathStartsWithRootDirectoryPath = path.startsWith(rootDirectoryPath);
        if (pathStartsWithRootDirectoryPath) {
            const length = rootDirectoryPath.length, start = length;
            path = path.substring(start); ///
            return true;
        }
    });
    return path;
}
function isDirectoryPathRootDirectoryPath(directoryPath, context) {
    const { rootDirectoryPaths } = context, rootDirectoryPathsIncludesDirectoryPath = rootDirectoryPaths.includes(directoryPath), directoryPathRootDirectoryPath = rootDirectoryPathsIncludesDirectoryPath; ///
    return directoryPathRootDirectoryPath;
}
function entryPathsFromEntryNamesAndDirectoryPath(entryNames, directoryPath) {
    const entryPaths = entryNames.map((entryName)=>{
        const entryPath = entryPathFromEntryNameAndDirectoryPath(entryName, directoryPath);
        return entryPath;
    });
    return entryPaths;
}
function entryPathFromEntryNameAndDirectoryPath(entryName, directoryPath) {
    const entryPath = directoryPath === _constants.CURRENT_DIRECTORY_PATH ? entryName : concatenatePaths(directoryPath, entryName);
    return entryPath;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsaXRpZXMvcGF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgcGF0aFV0aWxpdGllcyB9IGZyb20gXCJuZWNlc3NhcnlcIjtcblxuaW1wb3J0IHsgQ1VSUkVOVF9ESVJFQ1RPUllfUEFUSCB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuY29uc3QgeyBjb25jYXRlbmF0ZVBhdGhzIH0gPSBwYXRoVXRpbGl0aWVzO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBSb290RGlyZWN0b3J5RnJvbVBhdGgocGF0aCwgY29udGV4dCkge1xuICBjb25zdCB7IHJvb3REaXJlY3RvcnlQYXRocyB9ID0gY29udGV4dDtcblxuICByb290RGlyZWN0b3J5UGF0aHMuc29tZSgocm9vdERpcmVjdG9yeVBhdGgpID0+IHtcbiAgICBjb25zdCBwYXRoU3RhcnRzV2l0aFJvb3REaXJlY3RvcnlQYXRoID0gcGF0aC5zdGFydHNXaXRoKHJvb3REaXJlY3RvcnlQYXRoKTtcblxuICAgIGlmIChwYXRoU3RhcnRzV2l0aFJvb3REaXJlY3RvcnlQYXRoKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSByb290RGlyZWN0b3J5UGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBzdGFydCA9IGxlbmd0aDtcblxuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKHN0YXJ0KTsgIC8vL1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEaXJlY3RvcnlQYXRoUm9vdERpcmVjdG9yeVBhdGgoZGlyZWN0b3J5UGF0aCwgY29udGV4dCkge1xuICBjb25zdCB7IHJvb3REaXJlY3RvcnlQYXRocyB9ID0gY29udGV4dCxcbiAgICAgICAgcm9vdERpcmVjdG9yeVBhdGhzSW5jbHVkZXNEaXJlY3RvcnlQYXRoID0gcm9vdERpcmVjdG9yeVBhdGhzLmluY2x1ZGVzKGRpcmVjdG9yeVBhdGgpLFxuICAgICAgICBkaXJlY3RvcnlQYXRoUm9vdERpcmVjdG9yeVBhdGggPSByb290RGlyZWN0b3J5UGF0aHNJbmNsdWRlc0RpcmVjdG9yeVBhdGg7IC8vL1xuXG4gIHJldHVybiBkaXJlY3RvcnlQYXRoUm9vdERpcmVjdG9yeVBhdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnRyeVBhdGhzRnJvbUVudHJ5TmFtZXNBbmREaXJlY3RvcnlQYXRoKGVudHJ5TmFtZXMsIGRpcmVjdG9yeVBhdGgpIHtcbiAgY29uc3QgZW50cnlQYXRocyA9IGVudHJ5TmFtZXMubWFwKChlbnRyeU5hbWUpID0+IHtcbiAgICBjb25zdCBlbnRyeVBhdGggPSBlbnRyeVBhdGhGcm9tRW50cnlOYW1lQW5kRGlyZWN0b3J5UGF0aChlbnRyeU5hbWUsIGRpcmVjdG9yeVBhdGgpO1xuXG4gICAgcmV0dXJuIGVudHJ5UGF0aFxuICB9KTtcblxuICByZXR1cm4gZW50cnlQYXRocztcbn1cblxuZnVuY3Rpb24gZW50cnlQYXRoRnJvbUVudHJ5TmFtZUFuZERpcmVjdG9yeVBhdGgoZW50cnlOYW1lLCBkaXJlY3RvcnlQYXRoKSB7XG4gIGNvbnN0IGVudHJ5UGF0aCA9IChkaXJlY3RvcnlQYXRoID09PSBDVVJSRU5UX0RJUkVDVE9SWV9QQVRIKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlOYW1lIDogLy8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jYXRlbmF0ZVBhdGhzKGRpcmVjdG9yeVBhdGgsIGVudHJ5TmFtZSk7XG5cbiAgcmV0dXJuIGVudHJ5UGF0aDtcbn1cbiJdLCJuYW1lcyI6WyJlbnRyeVBhdGhzRnJvbUVudHJ5TmFtZXNBbmREaXJlY3RvcnlQYXRoIiwiaXNEaXJlY3RvcnlQYXRoUm9vdERpcmVjdG9yeVBhdGgiLCJzdHJpcFJvb3REaXJlY3RvcnlGcm9tUGF0aCIsImNvbmNhdGVuYXRlUGF0aHMiLCJwYXRoVXRpbGl0aWVzIiwicGF0aCIsImNvbnRleHQiLCJyb290RGlyZWN0b3J5UGF0aHMiLCJzb21lIiwicm9vdERpcmVjdG9yeVBhdGgiLCJwYXRoU3RhcnRzV2l0aFJvb3REaXJlY3RvcnlQYXRoIiwic3RhcnRzV2l0aCIsImxlbmd0aCIsInN0YXJ0Iiwic3Vic3RyaW5nIiwiZGlyZWN0b3J5UGF0aCIsInJvb3REaXJlY3RvcnlQYXRoc0luY2x1ZGVzRGlyZWN0b3J5UGF0aCIsImluY2x1ZGVzIiwiZGlyZWN0b3J5UGF0aFJvb3REaXJlY3RvcnlQYXRoIiwiZW50cnlOYW1lcyIsImVudHJ5UGF0aHMiLCJtYXAiLCJlbnRyeU5hbWUiLCJlbnRyeVBhdGgiLCJlbnRyeVBhdGhGcm9tRW50cnlOYW1lQW5kRGlyZWN0b3J5UGF0aCIsIkNVUlJFTlRfRElSRUNUT1JZX1BBVEgiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztRQW1DZ0JBO2VBQUFBOztRQVJBQztlQUFBQTs7UUFuQkFDO2VBQUFBOzs7MkJBTmM7MkJBRVM7QUFFdkMsTUFBTSxFQUFFQyxnQkFBZ0IsRUFBRSxHQUFHQyx3QkFBYTtBQUVuQyxTQUFTRiwyQkFBMkJHLElBQUksRUFBRUMsT0FBTztJQUN0RCxNQUFNLEVBQUVDLGtCQUFrQixFQUFFLEdBQUdEO0lBRS9CQyxtQkFBbUJDLElBQUksQ0FBQyxDQUFDQztRQUN2QixNQUFNQyxrQ0FBa0NMLEtBQUtNLFVBQVUsQ0FBQ0Y7UUFFeEQsSUFBSUMsaUNBQWlDO1lBQ25DLE1BQU1FLFNBQVNILGtCQUFrQkcsTUFBTSxFQUNqQ0MsUUFBUUQ7WUFFZFAsT0FBT0EsS0FBS1MsU0FBUyxDQUFDRCxRQUFTLEdBQUc7WUFFbEMsT0FBTztRQUNUO0lBQ0Y7SUFFQSxPQUFPUjtBQUNUO0FBRU8sU0FBU0osaUNBQWlDYyxhQUFhLEVBQUVULE9BQU87SUFDckUsTUFBTSxFQUFFQyxrQkFBa0IsRUFBRSxHQUFHRCxTQUN6QlUsMENBQTBDVCxtQkFBbUJVLFFBQVEsQ0FBQ0YsZ0JBQ3RFRyxpQ0FBaUNGLHlDQUF5QyxHQUFHO0lBRW5GLE9BQU9FO0FBQ1Q7QUFFTyxTQUFTbEIseUNBQXlDbUIsVUFBVSxFQUFFSixhQUFhO0lBQ2hGLE1BQU1LLGFBQWFELFdBQVdFLEdBQUcsQ0FBQyxDQUFDQztRQUNqQyxNQUFNQyxZQUFZQyx1Q0FBdUNGLFdBQVdQO1FBRXBFLE9BQU9RO0lBQ1Q7SUFFQSxPQUFPSDtBQUNUO0FBRUEsU0FBU0ksdUNBQXVDRixTQUFTLEVBQUVQLGFBQWE7SUFDdEUsTUFBTVEsWUFBWSxBQUFDUixrQkFBa0JVLGlDQUFzQixHQUNwQ0gsWUFDRW5CLGlCQUFpQlksZUFBZU87SUFFekQsT0FBT0M7QUFDVCJ9